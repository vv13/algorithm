由于要求`O(logN)`，在这题中还是应该采用二分法，由于普通的二分法只需要判断中位数与`target`的大小，若`target`较大则保留右边，否则保留左边；而对于旋转过的数组，我们需要用特别条件进行判断，先来看一下对于数组：`[1, 2, 3, 4, 5, 6 ,7]`，它旋转后的结果有可能如下：
```
[1, 2, 3, 4, 5, 6 ,7]
[5, 6 ,7, 1, 2, 3, 4]
[3, 4, 5, 6 ,7, 1, 2]
[7, 1, 2, 3, 4, 5, 6]
[5, 6, 7, 1, 2, 3, 4]
```

首先取 `start = 0` 和 `end = len(arrs)` 索引，中位数取值为：`mid = end - start`，此时观察结果集可以看出，旋转后的数组，总有一边为顺序数组：
- 若 `arrs[start] < arrs[mid]`，则左边数组为顺序数组
- 若 `arrs[end] > arrs[mid]`，则右边数组为顺序数组

我们选取任意选取一边进行条件判断：
  - 判断该边是否为顺序数组，若不为顺序数组，则选取另一边进行判断
  - 然后判断 `target` 是否位于该顺序数组中，若不属于此顺序数组，则该值包含于22位于非顺序数组中

这里还有一个特殊情况，假设只有2位数的情况：`[2, 1]`，target 为 1，这时 `start = 0, end = 1, mid = 0`，请注意我们上一步份当选好顺序数组的一边后，总是会判断 target 是否处于该顺序范围内，若不在范围内则从另一边开始搜索，但是由于`start = mid` 这个条件，target 是一定不会在范围内的，这时我们搜索的方向就会对结果造成影响：
- 若从左边开始搜索，则会判定 target 不在范围，一定会从右边开始搜索，此时结果执行正确
- 若从右边开始搜索，则会判断 target 不在范围，一定会从左边开始搜索，此时无解

因此，我们要保证当 `start = mid`时，先从左边开始搜索，因此我们会优先判断左边是否为顺序数组：`elif nums[mid] >= nums[start]:`，此时函数执行正确。



